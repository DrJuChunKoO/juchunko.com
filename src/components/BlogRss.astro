---
import { useTranslations } from "src/i18n/utils";

type SupportedLang = "en" | "zh-TW";

interface BlogPost {
	id: string;
	title: string;
	description?: string;
	link: string;
	pubDate: string;
	category?: string;
	author?: string;
}

type BlogRssProps = {
	lang: SupportedLang;
	limit?: number;
};

const { lang = "zh-TW", limit = 5 } = Astro.props as BlogRssProps;
const t = useTranslations(lang);

const RSS_URL = lang === "en" ? "https://blog.juchunko.com/rss.xml" : "https://blog.juchunko.com/rss.xml";

const dateFormatter = new Intl.DateTimeFormat(lang === "en" ? "en-US" : "zh-TW", {
	year: "numeric",
	month: lang === "en" ? "short" : "2-digit",
	day: "2-digit",
});

// Function to decode HTML entities
function decodeHtmlEntities(text: string): string {
	const namedEntities: Record<string, string> = {
		"&apos;": "'",
		"&quot;": '"',
		"&amp;": "&",
		"&lt;": "<",
		"&gt;": ">",
		"&nbsp;": "\u00a0",
		"&hellip;": "…",
		"&mdash;": "—",
	};

	return text.replace(/&(?:#\d+|#x[0-9a-fA-F]+|[a-zA-Z]+);/g, (entity) => {
		if (entity.startsWith("&#x") || entity.startsWith("&#X")) {
			const codePoint = Number.parseInt(entity.slice(7, -1), 16);
			return Number.isFinite(codePoint) ? String.fromCodePoint(codePoint) : entity;
		}

		if (entity.startsWith("&#")) {
			const codePoint = Number.parseInt(entity.slice(6, -1), 10);
			return Number.isFinite(codePoint) ? String.fromCodePoint(codePoint) : entity;
		}

		return namedEntities[entity] ?? entity;
	});
}

async function fetchRSS(): Promise<BlogPost[]> {
	try {
		const response = await fetch(RSS_URL, {
			method: "GET",
			headers: { accept: "application/xml" },
			cache: "no-store",
		});

		if (!response.ok) {
			throw new Error(`Failed to fetch RSS: ${response.status} ${response.statusText}`);
		}

		const xmlText = await response.text();

		// Simple XML parsing for RSS
		const items: BlogPost[] = [];
		const itemRegex = /<item>(.*?)<\/item>/gs;
		const titleRegex = /<title>(.*?)<\/title>/;
		const linkRegex = /<link>(.*?)<\/link>/;
		const descriptionRegex = /<description>(.*?)<\/description>/;
		const pubDateRegex = /<pubDate>(.*?)<\/pubDate>/;
		const categoryRegex = /<category>(.*?)<\/category>/;
		const authorRegex = /<author>(.*?)<\/author>/;
		const guidRegex = /<guid[^>]*>(.*?)<\/guid>/;

		let match;
		while ((match = itemRegex.exec(xmlText)) !== null) {
			const itemXml = match[1];

			const titleMatch = titleRegex.exec(itemXml);
			const linkMatch = linkRegex.exec(itemXml);
			const descriptionMatch = descriptionRegex.exec(itemXml);
			const pubDateMatch = pubDateRegex.exec(itemXml);
			const categoryMatch = categoryRegex.exec(itemXml);
			const authorMatch = authorRegex.exec(itemXml);
			const guidMatch = guidRegex.exec(itemXml);

			if (titleMatch && linkMatch) {
				const link = linkMatch[1];
				// Filter posts based on language
				const isEnglishPost = link.includes("/en/");
				const isChinesePost = link.includes("/zh/") || (!link.includes("/en/") && !link.includes("/zh/"));

				const shouldInclude = (lang === "en" && isEnglishPost) || (lang === "zh-TW" && isChinesePost);

				if (shouldInclude) {
					const id = guidMatch ? guidMatch[1] : link;
					const title = decodeHtmlEntities(titleMatch[1].replace(/<!\[CDATA\[(.*?)\]\]>/g, "$1"));
					const description = descriptionMatch ? decodeHtmlEntities(descriptionMatch[1].replace(/<!\[CDATA\[(.*?)\]\]>/g, "$1")) : undefined;
					const pubDate = pubDateMatch ? pubDateMatch[1] : "";
					const category = categoryMatch ? decodeHtmlEntities(categoryMatch[1]) : undefined;
					const author = authorMatch ? decodeHtmlEntities(authorMatch[1]) : undefined;

					items.push({
						id,
						title,
						description,
						link,
						pubDate,
						category,
						author,
					});
				}
			}
		}

		return items;
	} catch (error) {
		console.error("Failed to fetch RSS:", error);
		return [];
	}
}

let posts: BlogPost[] = [];
let fetchError = false;

try {
	const allPosts = await fetchRSS();
	posts = allPosts.slice(0, limit);
} catch (error) {
	console.error("Failed to fetch blog RSS:", error);
	fetchError = true;
}

const timestamps = posts.map((post) => post.pubDate).filter((value): value is string => value.length > 0);
const lastUpdatedRaw = timestamps.sort((a, b) => (a > b ? 1 : -1)).at(-1) ?? null;
const lastUpdatedLabel = lastUpdatedRaw ? dateFormatter.format(new Date(lastUpdatedRaw)) : null;

const hasData = posts.length > 0;
---

<section class="">
	{
		fetchError ? (
			<p class="rounded-lg border border-red-300 bg-red-50 px-4 py-3 text-sm text-red-700 dark:border-red-800 dark:bg-red-900/30 dark:text-red-200">
				{t("home.blogRss.fetchError")}
			</p>
		) : !hasData ? (
			<p class="rounded-lg border border-slate-200 bg-slate-50 px-4 py-3 text-sm text-slate-600 dark:border-slate-700 dark:bg-slate-800/60 dark:text-slate-300">
				{t("home.blogRss.empty")}
			</p>
		) : (
			<div class="grid grid-cols-[repeat(auto-fill,minmax(270px,1fr))] gap-4">
				{posts.map((post) => (
					<a
						class="border-accent hover:border-primary/25 group relative flex flex-col items-start overflow-hidden rounded-xl border-2 p-0.5 shadow-black/5 transition-all hover:-translate-y-1 hover:shadow-lg md:p-4 dark:hover:translate-0"
						target="_blank"
						rel="noopener noreferrer"
						href={post.link}
					>
						<article class="p-2 md:p-0" data-id={post.id}>
							{post.category && <div class="text-sm text-gray-500">{post.category}</div>}
							<h2 class="text-sm font-semibold md:text-lg">{post.title}</h2>
							<p class="text-xs tracking-tight text-gray-500 md:text-sm">
								{new Date(post.pubDate).toLocaleDateString(lang, {
									year: "numeric",
									month: "long",
									day: "numeric",
								})}
							</p>
							{post.description && <p class="mt-1 text-sm text-slate-600 dark:text-slate-300">{post.description}</p>}
						</article>
					</a>
				))}
			</div>
		)
	}
</section>