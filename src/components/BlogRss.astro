---
import { useTranslations } from "src/i18n/utils";

type SupportedLang = "en" | "zh-TW";

interface BlogPost {
	id: string;
	title: string;
	description?: string;
	link: string;
	pubDate: string;
	category?: string;
	author?: string;
}

type BlogRssProps = {
	lang: SupportedLang;
	limit?: number;
};

const { lang = "zh-TW", limit = 5 } = Astro.props as BlogRssProps;
const t = useTranslations(lang);

const RSS_URL = lang === "en" ? "https://blog.juchunko.com/rss.xml" : "https://blog.juchunko.com/rss.xml";

const dateFormatter = new Intl.DateTimeFormat(lang === "en" ? "en-US" : "zh-TW", {
	year: "numeric",
	month: lang === "en" ? "short" : "2-digit",
	day: "2-digit",
});

async function fetchRSS(): Promise<BlogPost[]> {
	try {
		const response = await fetch(RSS_URL, {
			method: "GET",
			headers: { accept: "application/xml" },
			cache: "no-store",
		});

		if (!response.ok) {
			throw new Error(`Failed to fetch RSS: ${response.status} ${response.statusText}`);
		}

		const xmlText = await response.text();

		// Simple XML parsing for RSS
		const items: BlogPost[] = [];
		const itemRegex = /<item>(.*?)<\/item>/gs;
		const titleRegex = /<title>(.*?)<\/title>/;
		const linkRegex = /<link>(.*?)<\/link>/;
		const descriptionRegex = /<description>(.*?)<\/description>/;
		const pubDateRegex = /<pubDate>(.*?)<\/pubDate>/;
		const categoryRegex = /<category>(.*?)<\/category>/;
		const authorRegex = /<author>(.*?)<\/author>/;
		const guidRegex = /<guid[^>]*>(.*?)<\/guid>/;

		let match;
		while ((match = itemRegex.exec(xmlText)) !== null) {
			const itemXml = match[1];

			const titleMatch = titleRegex.exec(itemXml);
			const linkMatch = linkRegex.exec(itemXml);
			const descriptionMatch = descriptionRegex.exec(itemXml);
			const pubDateMatch = pubDateRegex.exec(itemXml);
			const categoryMatch = categoryRegex.exec(itemXml);
			const authorMatch = authorRegex.exec(itemXml);
			const guidMatch = guidRegex.exec(itemXml);

			if (titleMatch && linkMatch) {
				const link = linkMatch[1];
				// Filter posts based on language
				const isEnglishPost = link.includes('/en/');
				const isChinesePost = link.includes('/zh/') || (!link.includes('/en/') && !link.includes('/zh/'));

				const shouldInclude = (lang === "en" && isEnglishPost) || (lang === "zh-TW" && isChinesePost);

				if (shouldInclude) {
					const id = guidMatch ? guidMatch[1] : link;
					const title = titleMatch[1].replace(/<!\[CDATA\[(.*?)\]\]>/g, '$1');
					const description = descriptionMatch ? descriptionMatch[1].replace(/<!\[CDATA\[(.*?)\]\]>/g, '$1') : undefined;
					const pubDate = pubDateMatch ? pubDateMatch[1] : "";
					const category = categoryMatch ? categoryMatch[1] : undefined;
					const author = authorMatch ? authorMatch[1] : undefined;

					items.push({
						id,
						title,
						description,
						link,
						pubDate,
						category,
						author,
					});
				}
			}
		}

		return items;
	} catch (error) {
		console.error("Failed to fetch RSS:", error);
		return [];
	}
}

let posts: BlogPost[] = [];
let fetchError = false;

try {
	const allPosts = await fetchRSS();
	posts = allPosts.slice(0, limit);
} catch (error) {
	console.error("Failed to fetch blog RSS:", error);
	fetchError = true;
}

const timestamps = posts.map((post) => post.pubDate).filter((value): value is string => value.length > 0);
const lastUpdatedRaw = timestamps.sort((a, b) => (a > b ? 1 : -1)).at(-1) ?? null;
const lastUpdatedLabel = lastUpdatedRaw ? dateFormatter.format(new Date(lastUpdatedRaw)) : null;

const hasData = posts.length > 0;
---

<section class="mt-8 rounded-xl border border-slate-200 bg-white p-6 shadow-sm dark:border-slate-800 dark:bg-slate-900/40">
	<header class="flex flex-col gap-2 md:flex-row md:items-center md:justify-between">
		<div>
			<h2 class="text-xl font-semibold text-slate-900 dark:text-white">{t("home.blogRss.title")}</h2>
			<p class="text-sm text-slate-600 dark:text-slate-300">{t("home.blogRss.subtitle")}</p>
		</div>
		{lastUpdatedLabel && (
			<p class="text-xs text-slate-500 dark:text-slate-400">
				{t("home.blogRss.updated")}: {lastUpdatedLabel}
			</p>
		)}
	</header>

	{fetchError ? (
		<p class="mt-6 rounded-lg border border-red-300 bg-red-50 px-4 py-3 text-sm text-red-700 dark:border-red-800 dark:bg-red-900/30 dark:text-red-200">
			{t("home.blogRss.fetchError")}
		</p>
	) : !hasData ? (
		<p class="mt-6 rounded-lg border border-slate-200 bg-slate-50 px-4 py-3 text-sm text-slate-600 dark:border-slate-700 dark:bg-slate-800/60 dark:text-slate-300">
			{t("home.blogRss.empty")}
		</p>
	) : (
		<div class="mt-6 space-y-4">
			{posts.map((post) => (
				<article
					class="rounded-lg border border-slate-200 bg-white/80 px-4 py-3 text-sm shadow-sm transition hover:border-slate-400 dark:border-slate-800 dark:bg-slate-900/60 dark:hover:border-slate-600"
					data-id={post.id}
				>
					<div class="flex flex-col gap-2">
						<div class="flex items-start justify-between gap-3">
							<h3 class="font-medium text-slate-900 dark:text-white">{post.title}</h3>
							<a class="shrink-0 text-xs font-medium text-blue-600 hover:text-blue-500 dark:text-blue-400" href={post.link} target="_blank" rel="noopener noreferrer">
								{t("home.blogRss.viewPost")}
							</a>
						</div>
						{post.description && (
							<p class="text-xs text-slate-600 dark:text-slate-300 line-clamp-2">
								{post.description}
							</p>
						)}
						<div class="grid gap-1 text-xs text-slate-600 dark:text-slate-300">
							{post.pubDate && (
								<div class="flex flex-wrap gap-1">
									<span class="font-medium text-slate-500 dark:text-slate-400">{t("home.legislatorActivity.date")}:</span>
									<span class="text-slate-700 dark:text-slate-200">{dateFormatter.format(new Date(post.pubDate))}</span>
								</div>
							)}
							{post.category && (
								<div class="flex flex-wrap gap-1">
									<span class="font-medium text-slate-500 dark:text-slate-400">Category:</span>
									<span class="text-slate-700 dark:text-slate-200">{post.category}</span>
								</div>
							)}
						</div>
					</div>
				</article>
			))}
		</div>
	)}
</section>